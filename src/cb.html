<!DOCTYPE html><html lang="en"><head><title>src\cb</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src\cb"><meta name="groc-project-path" content="src\cb.coffee"><meta name="groc-github-url" content="https://github.com/tectual/odme"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/tectual/odme/blob/master/src\cb.coffee">src\cb.coffee</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">Base = <span class="hljs-built_in">require</span> <span class="hljs-string">'./base'</span>
Boom = <span class="hljs-built_in">require</span> <span class="hljs-string">'boom'</span>
JsonMask = <span class="hljs-built_in">require</span> <span class="hljs-string">'json-mask'</span>
_    = <span class="hljs-built_in">require</span> <span class="hljs-string">'lodash'</span>
Promise = <span class="hljs-built_in">require</span> <span class="hljs-string">'bluebird'</span>
es = <span class="hljs-built_in">require</span> <span class="hljs-string">'elasticsearch'</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="model-layer-using-puffer-library-https-www-npmjs-com-package-puffer-">Model Layer Using <a href="https://www.npmjs.com/package/puffer">puffer library</a></h2>
<p>This Model class is using puffer for CRUDing. It&#39;s recommended to read <a href="https://www.npmjs.com/package/puffer">puffer&#39;s documentation</a> first.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>this must be an object.</strong><br/>(is the port, host, index name of elasticsearch and source of base.)</p>
</li>
<li><p><strong>this must be an object.</strong><br/>(is the elastic search client. if client is not passed one is created from config)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(config, client)</span> -&gt;</span>
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>

    <span class="hljs-attribute">source</span>: config.source</div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method get(key[, raw])</span></p>
<h2 id="get">Get</h2>
<p>Get the existing doc by key and instantiate an ODME object. The returned object has <code>.is_new</code> property set to <code>false</code>. If you don&#39;t need the ODME object and only need the doc to work with, you should pass <code>true</code> as the second parameter which will return the raw Couchbase Document and it&#39;s slightly faster.</p>
<p>If you pass an array list of keys, it can get all those documents, only if they all exists.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>key must be a string.</strong><br/>((s) document key(s) which should be retrieved)</p>
</li>
<li><p><strong>raw must be a boolean.</strong><br/>(if it should return raw document)</p>
</li>
</ul>
<p>Example:</p>
<pre><code>recipe.get(&#39;recipe_uX87dkF3Bj&#39;).then (d) -&gt; console.log d</code></pre></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@get</span>: <span class="hljs-function"><span class="hljs-params">(key, raw)</span>-&gt;</span>
      <span class="hljs-keyword">return</span> Promise.resolve( <span class="hljs-keyword">if</span> _.isArray(key) <span class="hljs-keyword">then</span> [] <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>) <span class="hljs-keyword">if</span> _.isEmpty key <span class="hljs-keyword">or</span> _.isNaN key
      raw ||= <span class="hljs-literal">false</span>
<span class="hljs-function">      <span class="hljs-title">make</span> = <span class="hljs-params">(key, <span class="hljs-built_in">document</span>)</span> =&gt;</span>
        instance = <span class="hljs-keyword">new</span> @ {}, key
        instance.doc = <span class="hljs-built_in">document</span>.value
        instance.cas = <span class="hljs-built_in">document</span>.cas
        instance.key = key
        instance.is_new = <span class="hljs-literal">false</span>
        instance
      @::source.get(key).<span class="hljs-keyword">then</span> (<span class="hljs-built_in">document</span>)-&gt;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">document</span>.isBoom || raw
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Array
          <span class="hljs-keyword">return</span> make( key, <span class="hljs-built_in">document</span> )
        list = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> key
          list.push make( i, <span class="hljs-built_in">document</span>[i] )
        list</div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method find(key[, raw[, as_object]])</span></p>
<h2 id="find">Find</h2>
<p>Find the existing doc by key (it can get list of keys as well). It can return raw Couchbase Document or the masked version of it. It uses <strong>props</strong> or <strong>_mask</strong> as default filter unless you pass the a string of mask as second parameter.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>key must be a string.</strong><br/>((s) document key(s) which should be retrieved)</p>
</li>
<li><p><strong>raw can be a boolean or a string.</strong><br/>(if it&#39;s true it returns raw document, if it is string, it will be considered as a mask. Default is false and it will mask the document)</p>
</li>
<li><p><strong>as_object must be a boolean.</strong><br/>(this property only works if the <code>raw</code> parameter is set to false. If it&#39;s true, it converts the array list of documents to the object, which means you can find a doc by it&#39;s <code>doc_key</code> in that object. It helps you to access documents in the result set by their keys.)</p>
</li>
</ul>
<p>Example:</p>
<pre><code>recipe.find(&#39;recipe_uX87dkF3Bj&#39;).then (d) -&gt; console.log d</code></pre></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@find</span>: <span class="hljs-function"><span class="hljs-params">(key, raw, asObject)</span>-&gt;</span>
      <span class="hljs-keyword">return</span> Promise.resolve( <span class="hljs-keyword">if</span> _.isArray(key) <span class="hljs-keyword">then</span> [] <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>) <span class="hljs-keyword">if</span> _.isEmpty key <span class="hljs-keyword">or</span> _.isNaN key
      @::source.get(key, <span class="hljs-literal">true</span>).<span class="hljs-keyword">then</span> (d)=&gt;
        <span class="hljs-keyword">return</span> d <span class="hljs-keyword">if</span> d.isBoom || (raw? &amp;&amp; raw == <span class="hljs-literal">true</span>)
        mask = (@::_mask()||<span class="hljs-literal">null</span>)
        mask = raw <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> raw == <span class="hljs-string">'string'</span>
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Array
          <span class="hljs-keyword">if</span> asObject? <span class="hljs-keyword">and</span> asObject
            (o = {})[d.docKey] = <span class="hljs-property">@mask</span> d, mask
            <span class="hljs-keyword">return</span> o
          <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-property">@mask</span> d, mask
        <span class="hljs-keyword">else</span>
          <span class="hljs-keyword">if</span> asObject? <span class="hljs-keyword">and</span> asObject
            list = {}
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d
              list[i.docKey] = <span class="hljs-property">@mask</span> i, mask
          <span class="hljs-keyword">else</span>
            list = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d
              list.push <span class="hljs-property">@mask</span> i, mask
          list</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private method maskOrData(data[, mask])</span></p>
<h2 id="mask-or-data">Mask or Data</h2>
<p>Check the CB callback&#39;s result and make sure there was no error. If so and masked version is requested, it will return the masked result.</p>
<p>Parameters:</p>
<ul>
<li><strong>mask can be a string, an array, or a true.</strong><br/>(this works exactly same way mask(mask) method works)</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">maskOrData</span>: <span class="hljs-function"><span class="hljs-params">(data, mask)</span>-&gt;</span>
      <span class="hljs-keyword">if</span> data.isBoom
        data
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ! mask
        <span class="hljs-property">@mask</span> <span class="hljs-property">@_mask</span>()
      <span class="hljs-keyword">else</span>
        <span class="hljs-property">@mask</span> mask</div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method create([mask])</span></p>
<h2 id="create">Create</h2>
<p>Create the doc in assigned key. It can return masked doc after creating.</p>
<p>Creation will only work if both <code>beforeCreate</code> and <code>beforeSave</code> return true (which they do by default unless you override them). You can use these methods to add your pre-creation logic to change the document or use them as validations.</p>
<p>After creating the doc, <code>afterSave</code> and <code>afterCreate</code> methods will be called. These are useful when you want to execute post creation logic.</p>
<p>Parameters:</p>
<ul>
<li><strong>mask can be a string, an array, or a true.</strong><br/>(this works same as mask(mask) method.)</li>
</ul>
<p>Example:</p>
<pre><code>recipe = new Recipe { name: &#39;Pasta&#39;, origin: &#39;Italy&#39; }
recipe.doc.popularity = 100
recipe.create(true).then (d) -&gt; console.log d</code></pre></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">create</span>: <span class="hljs-function"><span class="hljs-params">(mask)</span> -&gt;</span>
      <span class="hljs-property">@lifeCycle</span>(mask, <span class="hljs-string">"Create"</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-property">@source</span>.insert(<span class="hljs-property">@key</span>, <span class="hljs-property">@doc</span>))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="handles-callbacks">Handles callbacks</h2>
<p>calls the before and after callbaks of create and update</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">lifeCycle</span>: <span class="hljs-function"><span class="hljs-params">(mask, type, fn)</span> -&gt;</span>
      before = Promise.method(@[<span class="hljs-string">"before<span class="hljs-subst">#{type}</span>"</span>].bind(@))
      beforeSave = Promise.method(<span class="hljs-property">@beforeSave</span>.bind(@))
      afterSave = Promise.method(<span class="hljs-property">@afterSave</span>.bind(@))
      after = Promise.method(@[<span class="hljs-string">"after<span class="hljs-subst">#{type}</span>"</span>].bind(@))
      before()
        .<span class="hljs-keyword">then</span> (passed) =&gt;
          <span class="hljs-keyword">throw</span> passed <span class="hljs-keyword">if</span> passed <span class="hljs-keyword">isnt</span> <span class="hljs-literal">true</span>
          beforeSave()
        .<span class="hljs-keyword">then</span> (passed) =&gt;
          <span class="hljs-keyword">throw</span> passed <span class="hljs-keyword">if</span> passed <span class="hljs-keyword">isnt</span> <span class="hljs-literal">true</span>
          <span class="hljs-property">@validateDoc</span>()
          fn(mask)
        .<span class="hljs-keyword">then</span> (data) =&gt;
          <span class="hljs-property">@maskOrData</span>(data, mask)
        .<span class="hljs-keyword">then</span> (data) =&gt;
          afterSave(data)
        .<span class="hljs-keyword">then</span> (data) =&gt;
          after(data)
        .<span class="hljs-keyword">catch</span> (err) -&gt;
          <span class="hljs-keyword">if</span> err <span class="hljs-keyword">instanceof</span> Error
            err
          <span class="hljs-keyword">else</span>
            Boom.notAcceptable <span class="hljs-string">"Validation failed"</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method update([mask])</span></p>
<h2 id="update">Update</h2>
<p>Update an existing doc using its key. It can return masked doc after saving and works in 2 different way:</p>
<h3 id="get-the-document-and-update-it">Get the document and update it</h3>
<p>You can get the document which means you have access to <code>.doc</code> property in the ODME object and all your pre-update callbacks can use the <code>.doc</code>. Once you are done with the ODME object you can call update and it will replace your <code>.doc</code> with the version in Data Storage.</p>
<pre><code>  Recipe.get(&quot;recipe_xhygd12gH3&quot;).then (recipe) -&gt;
    recipe.doc.name = &#39;Pasta&#39;
    recipe.update()</code></pre>
<h3 id="update-a-document-using-a-new-odme-object">Update a document using a new ODME object</h3>
<p>You instantiate a new ODME object with the key of previously stored docuemnt and assign your proeprties to its <code>.doc</code>. When <code>.update()</code> method is called, it will replace get the old doc internally and merge your new properties into it.</p>
<pre><code>  recipe = new Recipe { name: &#39;Pasta&#39; }, &quot;recipe_xhygd12gH3&quot;
  recipe.update()</code></pre>
<p><strong>Note:</strong> Remember update works asynchronously, therefore if you want to do some actions after it you should define them in <code>.then</code>.</p>
<p>Same as <code>create</code> method we have <code>beforeUpdate</code>, <code>beforeSave</code>, <code>afterSave</code> and <code>afterUpdate</code> callbacks hooked to update.</p>
<p>Parameters:</p>
<ul>
<li><strong>mask can be a string, an array, or a true.</strong><br/>(this works same as mask(mask) method.)</li>
</ul>
<p>Example:</p>
<pre><code>recipe = new Recipe &quot;recipe_xhygd12gH3&quot;, { name: &#39;Anti Pasta&#39; }
recipe.update(true).then (d) -&gt; console.log d</code></pre></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">update</span>: <span class="hljs-function"><span class="hljs-params">(mask)</span> -&gt;</span>
      <span class="hljs-property">@lifeCycle</span> mask, <span class="hljs-string">"Update"</span>, <span class="hljs-function"><span class="hljs-params">(mask)</span> =&gt;</span>
        update =
          <span class="hljs-keyword">if</span> <span class="hljs-property">@is_new</span>
            <span class="hljs-property">@source</span>.update <span class="hljs-property">@key</span>, <span class="hljs-property">@doc</span>
          <span class="hljs-keyword">else</span>
            <span class="hljs-property">@source</span>.replace <span class="hljs-property">@key</span>, <span class="hljs-property">@doc</span>, { <span class="hljs-attribute">cas</span>: <span class="hljs-property">@cas</span> }
        update
          .<span class="hljs-keyword">then</span> (data) =&gt;
            <span class="hljs-keyword">return</span> data <span class="hljs-keyword">if</span> data.isBoom
            <span class="hljs-property">@source</span>.get(<span class="hljs-property">@key</span>, <span class="hljs-literal">true</span>)
              .<span class="hljs-keyword">then</span> (result) =&gt;
                <span class="hljs-property">@doc</span> = result
                result</div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method remove(key)</span></p>
<h2 id="delete">Delete</h2>
<p>Delete the existing doc by key. It return true or the error object</p>
<p>Parameters:</p>
<ul>
<li><strong>key must be a string.</strong><br/>(document key which should be removed)</li>
</ul>
<p>Example:</p>
<pre><code>Recipe.remove(&#39;recipe_UYd3f1Ty65&#39;).then (d) -&gt; console.log d</code></pre></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@remove</span>: <span class="hljs-function"><span class="hljs-params">(key)</span>-&gt;</span>
      @::source.remove(key)
        .<span class="hljs-keyword">then</span> (data)-&gt;
          <span class="hljs-keyword">return</span> data <span class="hljs-keyword">if</span> data.isBoom
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="before-update-callback">Before update Callback</h2>
<p>Before Update can be used to assign values or as validation. It should return true to update the doc. If it returns false, ODME will return Boom Error. If you want to have your own error message make sure you are returning a Boom Error object at the end of this method on failures.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">beforeUpdate</span>: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="before-create-callback">Before create Callback</h2>
<p>Before Create can be used to assign values or as validation. It should return true to create the doc. If it returns false, ODME will return Boom Error. If you want to have your own error message make sure you are returning a Boom Error object at the end of this method on failures.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">beforeCreate</span>: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="before-save-callback">Before save Callback</h2>
<p>Before Save can be used to assign values or as validation. It should return true to create/update the doc. If it returns false, ODME will return Boom Error. If you want to have your own error message make sure you are returning a Boom Error object at the end of this method on failures.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">beforeSave</span>: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="after-create-callback">After Create Callback</h2>
<p>After create hook to do extra processing on the result. If you want the data being passed in promises chain after calling <strong>afterCreate</strong> make sure you are returning it. <code>afterCreate</code> callback will be called before this.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">afterCreate</span>: <span class="hljs-function"><span class="hljs-params">(data)</span> -&gt;</span> <span class="hljs-keyword">return</span> data</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="after-update-callback">After Update Callback</h2>
<p>Override after update callback in your models. If you want the data being passed in promises chain after calling <strong>afterUpdate</strong> make sure you are returning it. This will be called only after update.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">afterUpdate</span>: <span class="hljs-function"><span class="hljs-params">(data)</span> -&gt;</span> <span class="hljs-keyword">return</span> data</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="after-save-callback">After Save Callback</h2>
<p>Override save callback in your models. If you want the data being passed in promises chain after calling <strong>afterSave</strong> make sure you are returning it. This will be called after create and update.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">afterSave</span>: <span class="hljs-function"><span class="hljs-params">(data)</span> -&gt;</span> <span class="hljs-keyword">return</span> data</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="handle-elasticsearch-data">Handle elasticsearch data</h2>
<p>this will handle the heavy lifting of getting the data you want in the format that you desire</p>
<p>Parameters:</p>
<ul>
<li><p><strong>return must be a string.</strong><br/>(result of Elastic query)</p>
</li>
<li><p><strong>the must be an options.</strong><br/>(same options that is passed to @search method)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@handleElasticData</span>: <span class="hljs-function"><span class="hljs-params">(data, options = {})</span> -&gt;</span>
      <span class="hljs-keyword">new</span> Promise (resolve) =&gt;
        total = data.hits.total
        <span class="hljs-keyword">if</span> options.keysOnly <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>
          list = _.map(data.hits.hits, <span class="hljs-string">"_id"</span>)
          resolve {total, list} <span class="hljs-keyword">if</span> options.format <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>
          resolve list
        <span class="hljs-keyword">if</span> options.couchbaseDocuments <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>
          <span class="hljs-property">@find</span>(_.map(data.hits.hits, <span class="hljs-string">"_id"</span>), options.mask)
            .<span class="hljs-keyword">then</span> (documents) -&gt;
              resolve {total, <span class="hljs-attribute">list</span>: documents} <span class="hljs-keyword">if</span> options.format <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>
              resolve documents
        <span class="hljs-keyword">else</span>
          list = _.map data.hits.hits, <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
            o._source.doc.docKey = o._id
            <span class="hljs-keyword">return</span> JsonMask(o._source.doc, options.mask)
          resolve {total, list} <span class="hljs-keyword">if</span> options.format <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>
          resolve list</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><h2 id="query-elastic">Query Elastic</h2>
<p>Parameters:</p>
<ul>
<li><p><strong>which must be a string.</strong><br/>(type of document should elastic query)</p>
</li>
<li><p><strong>the must be an object.</strong><br/>(query itself)</p>
</li>
<li><p><strong>there must be an object.</strong><br/>(many field you can set in options field: searchType specifies the search type that ES should use for example count, keysOnly will return only the doc_keys of the documents, format will return the documents and the total number of them, setting couchbaseDocuments to true will return get the list from couchbase, mask will mask the result of data that is returned by CB)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@search</span>: <span class="hljs-function"><span class="hljs-params">(type, query, options = {})</span> -&gt;</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-string">'config cannot be empty'</span> <span class="hljs-keyword">unless</span> config?
      query.index = config.index
      query.type = type
      query.search_type = options.searchType <span class="hljs-keyword">if</span> options.searchType?
      <span class="hljs-keyword">unless</span> client?
        client = <span class="hljs-keyword">new</span> es.Client
          <span class="hljs-attribute">host</span>: <span class="hljs-string">"<span class="hljs-subst">#{config.host}</span>:<span class="hljs-subst">#{config.port}</span>"</span>
      client.search(query)
        .<span class="hljs-keyword">then</span> (result) =&gt;
          <span class="hljs-property">@handleElasticData</span>(result, options)
        .<span class="hljs-keyword">catch</span> (err) -&gt;
          <span class="hljs-keyword">throw</span> err</div></div></div></div></body></html>